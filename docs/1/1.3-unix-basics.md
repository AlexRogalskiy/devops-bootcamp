# Unix Basics
# Learning The Command Line

The command line is a simple text interface for interacting with your commputer. At first, using a command line interface can be intimedating, but as you get more comfortable with it, you'll find that it becomes a powerful tool. This guide is aimed at beginners with the command line, to learn some basic uses.

## Command Line Navigation

To begin with, you'll need to get a command line prompt on your computer. The process for this varies from computer to computer, but the application you want may be called something like 'terminal', 'shell', or 'command line'. From here on, this tutorial will refer to the application as a terminal.

At any moment, a terminal has a location it is working from within your folders. This is called the working directory. Some commands you use may have different results depending on the working directory, so it can be useful to know what it is.

To determine what your working directory is, use the command `pwd`, which stands for 'print working directory'.

If you just opened your terminal your working directory is most likely your user's home directory. However, you can also change to your home directory by typing `cd ~`. `cd` stands for change directory, and `~` is a shorthand to denote the home directory.

Try `pwd` again, and see if you get a different result.

Now that you've navigated to your home directory, you can make a new directory with, `mkdir liatrio_console_tutorial`.

Now navigate into the directory `cd liatrio_console_tutorial`

Tip: If you're typing out a long file or directory name, you can press the <tab> key to attempt to auto-complete it. If what you've typed is enough to identify the file, it will be filled in automatically. If you haven't typed enough to identify a single file, you can press <tab> twice to be shown a list of possibilities.

The commands so far:
```
pwd
cd ~
pwd
mkdir liatrio_console_tutorial
cd liatrio_console_tutorial
```

Next lets try making a file. The `touch` command updates the history of a file, without changing it. If the file doesn't exist, it will create it. Run the command `touch my_file`.

If we want to see that the file was created, you can use the `ls` command to list the files in a directory. Just type `ls`, you should see the file you just created.

Lets make another file `touch .my_hidden_file`. Try running `ls` again. This time your new file shouldn't show up. This is because the filename starts with `.`, denoting a hidden files. Hidden files aren't displayed by `ls` by default, however many commands like `ls` accept optional flags to slightly modify their behavior. To list all files, including hidden ones you can use the `-a` flag, which is used like `ls -a`. This time, your hidden file should display, along with some others that we'll discuss later.

Another useful command allows you to search a part of your system for files if you don't know where they're located. Run `find ~/liatrio_console_tutorial -name my_file`. In this case find will quickly locate the file.

The commands for this section:
```
touch my_file
ls
touch .my_hidden_file
ls
ls -a
find ~/liatrio_console_tutorial -name my_file
```

Now lets try displaying files. The `cat` command will concatenate and print files to the console. Try running `cat my_file`. You'll notice that nothing prints out, that's because the file doesn't actually have any content yet, it's just empty.

To generate something to put in the file, we'll use the `echo` command. Like you might expect `echo` simply repeats back exactly what you give it. Try running `echo "Hello World"`. You'll see that `echo` prints data to the screen, but we want it to go into our file. To accomplish this, we can use a file redirection operator. If we write, `> filename` after a command, the output will be printed to the file instead. Try running `echo "Hello World" > my_file`

Now we can test if we succeeded, by running `cat my_file`.
Lets say we want to add something to our file, try running `echo "File redirection is cool" > my_file`. If you `cat my_file` you'll see it didn't work. We overwrote our first message, instead of adding it to the end. If we want to add to the end of file, we instead should use the `>> filename` redirection. So let's try `echo "Second try" >> my_file`. Now you can `cat my_file` and see that it worked.

Commands for this section:
```
cat my_file
echo "Hello World"
echo "Hello World" > my_file
cat my_file
echo "File redirection is cool" > my_file
cat my_file
echo "Second try" >> my_file
cat my_file
```

For this next section lets talk about the `grep` command. `grep` can search a file for a pattern. This can be useful if know something is in a file, but the file is too large to search by hand. Try running `grep Second my_file`. Here 'Second' is the pattern we're searching for. Notice that `grep` prints out the whole line in the response giving some context for what was found.

Imagine that we'd like to search not just files, but also the output of other comamnds. As an example `touch find_me`. One way we can use `grep` to accomplish this is to `ls > temp_file` and then `grep find_me temp_file`. However, wanting to use the output of one command as the input for another is a fairly command situation. Instead of using a file as an inbetween, we can use the `|`, called a 'pipe'. A pipe is perfect for this situation, it does exactly what we want, passing the output of the first command, as input for the second. Run `ls | grep find_me`. Notice that the output is exactly the same, but this time we didn't require an extra file.

Commands for this section:
```
grep Second my_file
touch find_me
ls > temp_file
grep find_me temp_file
ls | grep find_me
```


