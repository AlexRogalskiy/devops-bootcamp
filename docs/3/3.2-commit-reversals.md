# Git Tutorial (Location Pending)

To begin, ensure that you have a GitHub account, and git installed on your computer. Using git will also require some familiarity with the command line.

Git is a system for managing versions and changes over time to a project. While git can be run purely locally, generally you use it alongside another tool, such as GitHub. GitHub serves as a remote store of the same information you have locally. Git and GitHub are not the same, but they are often used together.

To begin, we'll make a new repository on GitHub. Navigate to [GitHub's Create a New Repoistory](https://github.com/new) page, and fill out the fields to create a new repository. If you want, you can just give it a name and ignore the other options. Once you submit you'll have created your new repository. If you choose not to initilize it with a README, or other files, you'll still be left with an empty repository. However, GitHub is now set up to accept new files that you send it.

On your own machine, open up a terminal and create a directory called 'Liatrio_Git_Tutorial', and then navigate inside your new directory. Now you have a local directory to store whatever data you'd like, but you'll need to tell git that this repository should be managed by it.To do this, you can use the command `git init`. This command creates a hidden directory named `.git` inside the current directory. That's hidden directory is managed entirly by git, and you can safely ignore it.

Now let's try adding a file to your repository. Make a new file called 'test' and put whatever you like in it. Even though you've added a file to your repository, git still won't pay attention to it. This is because git tracks changes to a project in blocks of related changes, called 'commits'. If git tracked every change, it would need to update for every single character someone added to a file. Instead git expects the user to tell it when a group of changes are ready, and what should be included in the group.

If you want to add you changes into the group you can use `git add test`, which will add every change to the test file since the last time git saw it. In this case, git has never seen the file before, so from its perspective everything has changed. Git still hasn't made a new commit with your changes however, it doesn't know if you might want to add other files as well. This step is called 'staging', where changes are ready to be commited, but git hasn't done so yet. If you're ever not sure what is staged currently, you can type `git status` which will show your staged changes. Once you're ready to commit type `git commit -m "Adds test file"`. Inside the apostrophes, put a message to be tied to this commit. Your commit message should be consise, but should explain what this commit does. If you look back through your commit history later you'd like to be able to see what each commit adds or changes.

If you run `git status` again, you should see that what was previously staged isn't any longer. Now that git has commited your changes, it is up to date with your work. However, if you reload your page on GitHub, you'll find that your changes don't show up there. This is because, git has so far only saved your work locally, you'll need to tell it about your remote repository for it to share updates with. To accoplish this, go to your GitHub repository, and copy the link it provides. The link should end with '.git'. GitHub actually provides two such links, an HTTPS link and an SSH link, if you're not comfortable with SSH, make sure you use the HTTPS link for now. In your terminal simply run the command `git remote add origin {YOUR_LINK}`. This tells git about your remote repository, and gives it the name 'origin' which is a common convention.

Now that git knows about your remote repo, you can tell it to send all the changes so far with the command `git push origin master`. This command simply tells git to put all the changes you've made so far into the repository 'origin' which we picked out previously. Notive that the command also refers to 'master', we'll come back to that later. If you reload your repository on GitHub, you should now see your file there.

While generally git controls the whole change process, GitHub also allows you to change fles directly. If you click on your test file, you should see whatever the file says, but at the top of the file, you'll also see a button that lets you 'edit this file'. Go ahead and edit the file to say 'Hello World'. GitHub is still working alongside git, so you'll have to commit your changes at the bottom of the page. Make sure to give it a commit message, and commit directly to 'master'. Again, we'll explain that more later. You should see that your changes we're made.

If you go back to your local copy of the file, you'll see that your changes aren't there yet. For now lets ignore that, make another change to the file locally, for example make it say 'Git is pretty cool'. Then make sure to add and commit your new change. Now lets try to push our local changes to GitHub. If you run the same `git push origin master` command as before, you'll notice that it fails. GitHub knows that the remote repository has changes that you haven't seen yet, so it won't let you push your own changes, or you might overwrite them. In order to get the changes from the remote to the local copy, we'll use the command `git pull origin master`. When you run this command however you'll get a warning 'Merge conflict in test'. This is because we changes the same file in two different locations, and git doesn't know which copy to use.

Even though git doesn't know what to do, it still does what it can. Instead of overwriting your changes, git keeps both copies and lets yor sort them out. If you try to edit your 'test' file, you'll see something strange. Whenever you have a merge conflict for the sections of the file that conflict, git keeps both versions. The conflicting area is wrapped in a large block of `<<<` and `>>>` and the two sections are separated by `===`. The block marked 'HEAD' will be your local version of the file, whereas the other block will be marked with a long string of letters and numbers. These letters and numbers corospond to the commit that you are resolving a conflict with.

The method for resolving a conflict varies on a case by case basis. Sometimes you'll only want one version of the changes, and you'll have to see which is better to keep. Sometimes you'll want some parts of each. In this case however, let's just keep both changes in their entiety. We can simply delete the marker lines of `<<<`, `===`, and `>>>`, and then save our changes. Whenever you resolve a merge conflict, you'll generally want to remove the markers denoting the conflicting sections. Make sure to commit your changes as well, from git's perspective, resolving the conflict was still making changes to the file. 

# Commit Reversals
Rebasing or "squashing" allows you to change the commit messages and rewrite git history. This should only be done if sensitive information is accidentally committed to git.

1. Create a new git repository on github. This can be public or private, and you can delete it afterwards.
  - go to github.com/<your_username> and click "new repository"
  - clone the repo locally
2. Add some files to the repository
  - to create files, you can simply echo some text and then pipe the output to a new file: `echo "this is an example" >> new file.txt`
  - add, commit, and push these contents up to github

Add some "sensitive content"
 - add a line with the text "SENSITIVE INFO" to one of your files
 - add, commit, and push your changes.
 - add some more changes, commit and push once again, so the bad password is not the last commit

Here we have created a problem. We have a commit that contains a password, or some other sensitive info, and if we delete it the info will still show up in the commit diff. We don't want to reset because we have commits after the password that we want to keep. There are a couple of approaches to fixing this:

## Option 1: git reset
Using a git reset, we can get rid of any commits after a specific point. As long as we don't use reset --hard the files themselves will not be changed, only the git history will be impacted. This is a good option if the trouble commit is near or at the current head of our git repository. To undo a commit with reset:

 - get the hash value of the commit just before the commit containing credentials
 - git log can be used to identify recent commits.
 - reset to that commit: `git reset 1a2b3c4` where 1a2b3c4 are the first 7 characters of the hash you just recorded
 - make the necessary changes to your file that gets rid of credentials using an editor, sed, etc.
 - commit the sanitized files
 - push the changes to remote using the -f flag
 This is a streamlined approach that is fairly easy, but at the cost of losing commit messages of anything staged after the offensive commit.

## Option 2: git rebase
Using a git rebase, we can remove only a single commit, which is useful for a commit that is not near the head, or for keeping important commit messages. To rebase:

 - get the hash value of the commit containing credentials
 - start an interactive rebase on that commit `git rebase -i 1a2b3c4^` where 1a2b3c4 are the first 7 characters of your hash
 - change 'pick' to 'edit' for the commit you want to change, and then exit the file
 - the rebase will stop when the 'edit' point is reached. Sanitize the commit by removing the credentials with an editor, sed command, etc.
 - add the changes if necessary: `git add <changed files>`
 - commit the changes using `git commit --amend -m "<new message here>"`
 - continue the rebase: `git rebase --continue`
 - push the changes to remote using the -f flag
This is a more involved approach, but allows all commits and history to be preserved.

These approaches both change git history, which will require a force push to propagate to the remote repository. Make sure you can force push, or ask an administrator to do it for you if necessary. Rewriting git history is a destructive process, and should only be carried out when necessary for security.

Another approach for deleting history of a specific file as opposed to a specific commit can be found here: https://help.github.com/articles/removing-sensitive-data-from-a-repository/

# Deliverable
Discuss why changing a git repository like this should be avoided and should be done to mitigate issues when it must be done.
